<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MOTH PRAYER — VANISHING BOCALS (v5.1)</title>
<style>
  :root { --bg: #0b0e13; --ink:#e9d8a6; --zap:#97dffc; }
  html,body { margin:0; height:100%; background:#0b0e13; color:#cbd5e1; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; background: radial-gradient(1200px 600px at 70% 20%, #131824 0, #0b0e13 60%, #07090c 100%); }
  .topbar { position: fixed; top:6px; left:8px; right:8px; display:flex; gap:12px; justify-content:space-between; font-weight:600; text-shadow: 0 1px 2px #0008; mix-blend-mode:screen; z-index:5; }
  .pill { background:#0f172acc; border:1px solid #1e293b; border-radius:999px; padding:6px 12px; }
  .title { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:10px; text-align:center; letter-spacing:.06em; pointer-events:auto; user-select:none; z-index:10; }
  .title h1 { color:var(--ink); margin:0; font-size: clamp(42px, 8vw, 90px); text-shadow: 0 0 12px #e9d8a650, 0 0 2px #fff3; font-weight:900; }
  .title p { color:#a3b2c7; margin:0; max-width: 72ch; }
  .blink { animation: blink 1.4s steps(2, start) infinite; }
  @keyframes blink { 50% { opacity: .35; } }
  .toast { position: fixed; top: 50%; left:50%; transform: translate(-50%, -50%); background:#0b0e13ee; border: 1px solid #2b3240; padding:8px 12px; border-radius:10px; font-size:14px; opacity:0; transition:opacity .3s; z-index:20; }
  .toast.show { opacity:1; }
  .btn { cursor:pointer; padding:10px 16px; border-radius:12px; border:1px solid #1e293b; background:#0f172acc; color:#cde; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="topbar">
  <div class="pill">Score: <span id="score">0</span></div>
  <div class="pill">Banks: <span id="banks">0</span> · Streak: <span id="streak">x1.0</span></div>
  <div class="pill">Light: <span id="lightPct">100%</span> · Lost: <span id="lost">0</span> · Jars: <span id="jars">0</span></div>
  <div class="pill">Time: <span id="time">00:00</span></div>
</div>

<div id="title" class="title">
  <h1>MOTH PRAYER — VANISHING BOCALS</h1>
  <p>Mark moths in your candle, then guide them to a nearby bocal to bank them. Bocals drain if neglected; when none remain, game over. Candle-out is also game over.</p>
  <p id="reasonLine" style="display:none;color:#ffcdd6;font-weight:700;">Reason:</p>
  <p class="blink" style="margin-top:10px;color:#b4c3d9;">Click anywhere or press Enter to begin. (Audio starts after your first click.)</p>
  <div style="display:flex; gap:10px; margin-top:8px;">
    <button id="closeBtn" class="btn" style="display:none;">Close Game</button>
    <button id="reloadBtn" class="btn" style="display:none;">Reload</button>
  </div>
</div>

<div class="hud"><div id="whisper" class="toast"></div></div>

<script>
(() => {
  // ==== Canvas bootstrap ====
  const canvas = document.getElementById('game');
  let ctx = canvas.getContext('2d', { alpha: false, desynchronized: true }) || canvas.getContext('2d');
  if (!ctx || typeof ctx.beginPath !== 'function') { document.body.innerHTML = '<div style="padding:20px;color:#fff;background:#000">Canvas init failed. Please reload.</div>'; return; }
  let W = canvas.width = innerWidth * devicePixelRatio;
  let H = canvas.height = innerHeight * devicePixelRatio;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';

  // ==== HUD refs ====
  const scoreEl = document.getElementById('score');
  const banksEl = document.getElementById('banks');
  const streakEl = document.getElementById('streak');
  const lightPctEl = document.getElementById('lightPct');
  const lostEl  = document.getElementById('lost');
  const jarsEl  = document.getElementById('jars');
  const timeEl = document.getElementById('time');
  const titleEl = document.getElementById('title');
  const reasonLine = document.getElementById('reasonLine');
  const whisperEl = document.getElementById('whisper');
  const closeBtn = document.getElementById('closeBtn');
  const reloadBtn = document.getElementById('reloadBtn');

  // Buttons
  closeBtn.addEventListener('click', () => { const closed = window.close(); setTimeout(() => { canvas.style.display='none'; titleEl.innerHTML='<h1>Good night.</h1><p style="color:#a3b2c7">You can close this tab now.</p>'; }, 50); });
  reloadBtn.addEventListener('click', () => location.reload());
// 1) Add this helper near your other helpers (outside draw()):
function drawMoth(m) {
  const s = m.size;
  const marked = m.markedUntil > state.t;
  const ang = Math.atan2(m.vy, m.vx);

  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.rotate(ang);

  // soft pink halo when marked (clear but gentle)
  if (marked) {
    const rem = Math.max(0, Math.min(1, (m.markedUntil - state.t) / state.markDurationMs));
    const glow = ctx.createRadialGradient(0, 0, s * 0.2, 0, 0, s * 2.6);
    glow.addColorStop(0, `rgba(255,140,170,${0.30 * rem})`);
    glow.addColorStop(1, `rgba(255,140,170,0)`);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(0, 0, s * 2.6, 0, Math.PI * 2); ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }

  // WINGS — bigger, clearer, outlined
  const wingFill = marked ? 'hsl(340,60%,82%)' : 'hsl(48,84%,78%)'; // soft pink vs pale gold
  const wingEdge = 'rgba(28,33,46,0.7)';
  ctx.fillStyle = wingFill;
  ctx.strokeStyle = wingEdge;
  ctx.lineWidth = 0.9 * DPR;

  // left wing (two curves forming a leaf shape)
  ctx.beginPath();
  ctx.moveTo(-0.10 * s, 0);
  ctx.quadraticCurveTo(-1.25 * s, -0.95 * s, -2.25 * s, 0);
  ctx.quadraticCurveTo(-1.25 * s, 0.95 * s, -0.10 * s, 0);
  ctx.fill(); ctx.stroke();

  // right wing (mirror)
  ctx.beginPath();
  ctx.moveTo(0.10 * s, 0);
  ctx.quadraticCurveTo(1.25 * s, -0.95 * s, 2.25 * s, 0);
  ctx.quadraticCurveTo(1.25 * s, 0.95 * s, 0.10 * s, 0);
  ctx.fill(); ctx.stroke();

  // subtle wing “vein”
  ctx.strokeStyle = 'rgba(28,33,46,0.35)';
  ctx.lineWidth = 0.6 * DPR;
  ctx.beginPath(); ctx.moveTo(-0.1 * s, 0); ctx.lineTo(-1.4 * s, 0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0.1 * s, 0); ctx.lineTo(1.4 * s, 0); ctx.stroke();

  // BODY — a small capsule with outline
  ctx.fillStyle = 'hsl(42,26%,74%)';
  ctx.strokeStyle = 'rgba(28,33,46,0.8)';
  ctx.lineWidth = 1.1 * DPR;
  ctx.beginPath();
  ctx.ellipse(0, 0, 0.48 * s, 1.12 * s, 0, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();

  // head/eye
  ctx.fillStyle = '#1c212e';
  ctx.beginPath(); ctx.arc(0.42 * s, -0.05 * s, 0.12 * s, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
}

  // ==== Audio (WebAudio) ====
  let audioCtx = null; // created on first user gesture
  const master = { node:null };
  const sfxState = {
    mark: { last: 0, act: 0, minGap: 0.18, max: 2 },
    bank: { last: 0, act: 0, minGap: 0.08, max: 2 },
    zap:  { last: 0, act: 0, minGap: 0.08, max: 1 },
  };
  let activeVoices = 0; const MAX_VOICES = 6;

  function ensureAudio(){
    if (audioCtx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return; // no audio support
    audioCtx = new Ctx();
    master.node = audioCtx.createGain();
    master.node.gain.value = 0.22;
    master.node.connect(audioCtx.destination);
  }
  function tryReserve(type, dur){
    if (!audioCtx) return false; const now = audioCtx.currentTime; const s = sfxState[type]; if (!s) return false;
    if (type==='mark' && (now - s.last < s.minGap)) return false; // throttle flutter
    if (s.act >= s.max) return false; if (activeVoices >= MAX_VOICES && type==='mark') return false;
    s.last = now; s.act++; activeVoices++;
    setTimeout(() => { s.act = Math.max(0, s.act-1); activeVoices = Math.max(0, activeVoices-1); }, Math.ceil(dur*1000)+10);
    return true;
  }
  let noiseBuf = null; function getNoiseBuf(){ if (noiseBuf) return noiseBuf; if (!audioCtx) return null; const dur = 0.35, sr = audioCtx.sampleRate, len = Math.floor(dur*sr); const buf = audioCtx.createBuffer(1, len, sr); const ch = buf.getChannelData(0); for (let i=0;i<len;i++) ch[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 1.2); noiseBuf = buf; return buf; }
  const SFX = {
    mark(){ if (!audioCtx) return; const t = audioCtx.currentTime; const dur = 0.3; if(!tryReserve('mark', dur)) return; const o1 = audioCtx.createOscillator(); const o2 = audioCtx.createOscillator(); const g = audioCtx.createGain(); const trem = audioCtx.createOscillator(); const tremGain = audioCtx.createGain(); o1.type='sine'; o2.type='sine'; o1.frequency.setValueAtTime(210, t); o2.frequency.setValueAtTime(240, t); g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.03, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+dur-0.02); trem.frequency.value = 11; tremGain.gain.value = 0.4; trem.connect(tremGain).connect(g.gain); o1.connect(g); o2.connect(g); g.connect(master.node); o1.start(t); o2.start(t); trem.start(t); const stopT = t+dur; o1.stop(stopT); o2.stop(stopT); trem.stop(stopT); },
    bank(){ if (!audioCtx) return; const t = audioCtx.currentTime; const dur = 0.55; if(!tryReserve('bank', dur)) return; const g = audioCtx.createGain(); g.gain.value = 0.0001; g.connect(master.node); const oA = audioCtx.createOscillator(); const oB = audioCtx.createOscillator(); oA.type='triangle'; oB.type='triangle'; oA.frequency.setValueAtTime(523.25, t); oB.frequency.setValueAtTime(659.25, t+0.12); oA.connect(g); oB.connect(g); g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.07, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); oA.start(t); oB.start(t+0.12); const stopT = t+dur; oA.stop(stopT); oB.stop(stopT); },
    zap(){ if (!audioCtx) return; const t = audioCtx.currentTime; const dur = 0.26; if(!tryReserve('zap', dur)) return; const noise = audioCtx.createBufferSource(); const buf = getNoiseBuf(); if(!buf) return; noise.buffer = buf; const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 900; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); noise.connect(hp).connect(g).connect(master.node); noise.start(t); const stopT = t+dur; noise.stop(stopT); }
  };
  ['click','keydown','touchstart'].forEach(ev=> addEventListener(ev, async()=>{ ensureAudio(); if(audioCtx && audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch{} } }, {once:false, passive:true}));

  // ==== Helpers ====
  const rnd = (a=1,b=0)=> Math.random()*(a-b)+b;
  const clamp = (x,a,b)=> x<a?a : x>b?b : x;
  function toast(text){ whisperEl.textContent=text; whisperEl.classList.add('show'); clearTimeout(toast._t); toast._t=setTimeout(()=>whisperEl.classList.remove('show'), 1600); }
  function fmtTime(ms){ ms=Math.max(0,ms|0); const s=Math.floor(ms/1000); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); const mm=String(m).padStart(2,'0'); return mm+':'+ss; }
  function insideAnyBocal(x,y){ for(const b of state.bocals){ const r = state.bocalR * (0.9 + 0.1*b.charge); if (Math.hypot(x-b.x, y-b.y) < r) return true; } return false; }
  function candlePosAvoidingBocals(x,y){ let cx=x, cy=y; for(const b of state.bocals){ const r = state.bocalR * (0.9 + 0.1*b.charge); const dx = cx - b.x, dy = cy - b.y; const d = Math.hypot(dx,dy) || 1; const minD = r * 1.02; if(d < minD){ const ux = dx/d, uy = dy/d; cx = b.x + ux * minD; cy = b.y + uy * minD; } } cx = clamp(cx, 0, W); cy = clamp(cy, 0, H); return {x:cx,y:cy}; }

  // ==== State ====
  const state = {
    running:false, t:0, playMs:0,
    score:0, saved:0, lost:0,
    banks:0, streak:0, mult:1.0, lastBankAt:0,
    mouse:{ x: W*0.5, y: H*0.7 },
    candle:{ r: 60*devicePixelRatio, minR: 0, maxR: 0 },
    moths:[],
    zapper:{ y: 28*devicePixelRatio, pulse:0 },
    spawn:{ next:0, baseMs:640, accel:0.993 },
    // Forces / balance
    zapperK: 11.0, zapperMax: 0.35,
    candlePull: 0.10, swarmBonus: 0.018,
    decayPerSec: 0.006, rechargePerSec: 0.035,
    lightLossOnDeath: 0.10, candleBaseR: 60*devicePixelRatio,
    // Moving bocal params with per-bocal charge
    bocals: [],
    bocalR: 70*devicePixelRatio,
    bocalSpeed: 0.05*devicePixelRatio,
    bocalZapMargin: 70*devicePixelRatio,
    // Per-bocal light system
    bocalGraceSec: 8,
    bocalDrainPerSec: 0.15,
    bocalBankGain: 0.35,
    // Banking rules
    markDurationMs: 6000,
    bocalActiveRangeFactor: 1.15,
    bankLightFrac: 0.10, bankScore: 25,
    multStep: 0.5, multMax: 4.0, streakTimeoutSec: 8,
  };

  const whispers=[ 'mark them in your light','only nearby jars will take names','don’t let jars go dark' ];

  // ==== Setup ====
  function setupCandle(){ state.candle.maxR = state.candleBaseR * 1.0; state.candle.minR = state.candleBaseR * 0.45; state.candle.r = state.candle.maxR; }
  function createBocals(){ state.bocals.length = 0; const y0 = H*0.55; state.bocals.push({ x: W*0.25, y: y0, vx: state.bocalSpeed, vy: -state.bocalSpeed*0.6, charge:1, idle:0 }); state.bocals.push({ x: W*0.75, y: y0-60*devicePixelRatio, vx: -state.bocalSpeed*0.8, vy: state.bocalSpeed*0.4, charge:1, idle:0 }); }
  function spawnMoth(){ const SAFE_TOP = H * 0.20; const randY = () => rnd(H - SAFE_TOP) + SAFE_TOP; const edge = Math.floor(rnd(4)); let x,y; if(edge===0){ x=rnd(W); y=H + 20; } else if(edge===1){ x=-20; y=randY(); } else if(edge===2){ x=W+20; y=randY(); } else { x=rnd(W); y=H + 20; } state.moths.push({ x,y, vx:rnd(-0.3,0.3), vy:rnd(-0.2,0.1), j:rnd(1000), energy:rnd(0.7,1.3), size:rnd(7,13)*devicePixelRatio, color:`hsl(${rnd(50,65)},${rnd(60,90)}%,${rnd(70,90)}%)`, inSafe:false, inTime:0, markedUntil:0 }); }
  function reset(){ state.t=0; state.playMs=0; state.score=0; state.saved=0; state.lost=0; state.banks=0; state.streak=0; state.mult=1.0; state.lastBankAt=0; state.moths.length=0; state.spawn.baseMs = 640; state.spawn.next=0; state.spawn.accel = 0.993; setupCandle(); createBocals(); for(let i=0;i<10;i++) spawnMoth(); reasonLine.style.display='none'; toast('mark, then bank'); }

  // ==== Input ====
  addEventListener('mousemove', (e)=>{ const r=canvas.getBoundingClientRect(); state.mouse.x=(e.clientX-r.left)*devicePixelRatio; state.mouse.y=(e.clientY-r.top)*devicePixelRatio; }, {passive:true});
  addEventListener('touchmove', (e)=>{ if(e.touches[0]){ const r=canvas.getBoundingClientRect(); state.mouse.x=(e.touches[0].clientX-r.left)*devicePixelRatio; state.mouse.y=(e.touches[0].clientY-r.top)*devicePixelRatio; } }, {passive:true});
  addEventListener('keydown', (e)=>{ if((e.code==='Enter') && !state.running) start(); });
  addEventListener('click', ()=>{ if(!state.running) start(); else if(Math.random()<.25) toast(whispers[(Math.random()*whispers.length)|0]); });

  // ==== Banking ====
  function bankMoth(bIndex){ state.banks++; state.streak++; state.mult = Math.min(state.multMax, 1 + state.streak * state.multStep); state.lastBankAt = performance.now(); const addLight = state.bankLightFrac * state.candle.maxR * state.mult; state.candle.r = clamp(state.candle.r + addLight, state.candle.minR, state.candle.maxR); state.score += Math.round(state.bankScore * state.mult); const b = state.bocals[bIndex]; if (b) { b.idle = 0; b.charge = clamp(b.charge + state.bocalBankGain * state.mult, 0, 1); } SFX.bank(); toast(`banked ×${state.mult.toFixed(1)}`); }
  function gameOver(reason){ state.running=false; titleEl.style.display='flex'; closeBtn.style.display='inline-block'; reloadBtn.style.display='inline-block'; reasonLine.textContent = 'Reason: ' + reason; reasonLine.style.display='block'; toast('defeat'); }

  // ==== Bocals update/draw ====
  function updateBocals(dt){
    const z = state.zapper.y + state.bocalZapMargin; const dtSec = dt/1000; const topLimit = H*0.15; const bottomLimit = H*0.80; // avoid top 15% & bottom 20%
    for(const b of state.bocals){
      if(Math.random()<0.006){ b.vx += rnd(-0.02,0.02)*devicePixelRatio; b.vy += rnd(-0.02,0.02)*devicePixelRatio; }
      const r = state.bocalR * (0.9 + 0.1*b.charge);
      if(b.y - r < z){ b.vy += (z - (b.y - r)) * 0.0006; }
      // integrate
      b.x += b.vx * dt; b.y += b.vy * dt;
      // bounds with vertical safe zone
      if(b.x - r < 0){ b.x = r; b.vx = Math.abs(b.vx); }
      if(b.x + r > W){ b.x = W - r; b.vx = -Math.abs(b.vx); }
      if(b.y - r < topLimit){ b.y = topLimit + r; b.vy = Math.abs(b.vy); }
      if(b.y + r > bottomLimit){ b.y = bottomLimit - r; b.vy = -Math.abs(b.vy); }
      // cap & damp speed
      const s = Math.hypot(b.vx,b.vy), max = state.bocalSpeed*2; if(s>max){ b.vx = b.vx/s*max; b.vy = b.vy/s*max; }
      b.vx *= 0.999; b.vy *= 0.999;
      // charge drain after grace
      b.idle += dtSec; if(b.idle > state.bocalGraceSec){ b.charge = clamp(b.charge - state.bocalDrainPerSec*dtSec, 0, 1); }
    }
    state.bocals = state.bocals.filter(b => b.charge > 0.0001);
  }

  function drawBocals(){
    for(const b of state.bocals){
      const r = state.bocalR * (0.9 + 0.1*b.charge);
      // Traffic-light palette by charge: green → blue → red
      const hue = (b.charge > 0.66) ? 120 : (b.charge > 0.33 ? 200 : 0);
      const sat = (b.charge > 0.66) ? 70 : (b.charge > 0.33 ? 80 : 85);
      const light = 60 + 20*b.charge;
      const coreAlpha = 0.18 + 0.34*b.charge;

      // glow
      const g = ctx.createRadialGradient(b.x,b.y, r*0.08, b.x,b.y, r);
      g.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, ${coreAlpha})`);
      g.addColorStop(0.6, `hsla(${hue}, ${Math.max(20, Math.floor(sat*0.6))}%, ${Math.floor(light*0.7)}%, ${coreAlpha*0.5})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation='source-over';

      // activation ring when candle is close enough
      const cpos = candlePosAvoidingBocals(state.mouse.x, state.mouse.y);
      const active = Math.hypot(cpos.x-b.x, cpos.y-b.y) < r*state.bocalActiveRangeFactor;
      ctx.strokeStyle = active ? `hsla(${hue}, ${sat}%, 75%, 0.75)` : `hsla(${hue}, ${Math.max(20,sat-20)}%, 65%, 0.35)`;
      ctx.lineWidth = 2*devicePixelRatio; ctx.beginPath(); ctx.arc(b.x,b.y,r*0.98,0,Math.PI*2); ctx.stroke();

      // charge meter arc (outer ring shows remaining charge)
      ctx.strokeStyle = `hsla(${hue}, ${sat}%, 70%, 0.9)`;
      ctx.lineWidth = 3*devicePixelRatio;
      ctx.beginPath();
      const start = -Math.PI/2; const end = start + Math.max(0.02, b.charge) * Math.PI*2;
      ctx.arc(b.x,b.y,r*1.03, start, end);
      ctx.stroke();
    }
  }

  // ==== Step ====
  function step(dt){
    state.t += dt; state.playMs += dt; const dtSec = dt/1000;
    state.spawn.next -= dt; if(state.spawn.next<=0){ spawnMoth(); state.spawn.baseMs *= state.spawn.accel; state.spawn.next = Math.max(200, state.spawn.baseMs + rnd(260, -200)); }
    const maxR = state.candle.maxR, minR = state.candle.minR; state.candle.r -= state.decayPerSec * maxR * dtSec;
    updateBocals(dt);
    const cpos = candlePosAvoidingBocals(state.mouse.x, state.mouse.y); const cx = cpos.x, cy = cpos.y, cr = state.candle.r;

    let insideCount = 0, mothsInLight = 0;
    for(const m of state.moths){
      const wander = (Math.sin((state.t + m.j)*0.005)*0.5) * 0.25*m.energy;
      const dx=cx-m.x, dy=cy-m.y; const dist=Math.hypot(dx,dy)+1e-3;
      const isInside = dist < cr*0.9; mothsInLight += isInside ? 1 : 0; insideCount += isInside ? 1 : 0;
      const pullMultiplier = 1 + (mothsInLight * state.swarmBonus);
      const pullC = clamp((cr*1.35)/dist, 0, 1.35) * state.candlePull * pullMultiplier * m.energy;
      const height = Math.max(12, m.y - state.zapper.y); const pullZ = Math.min(state.zapperK / height, state.zapperMax);

      m.vx += (dx/dist)*pullC + wander*0.2 + (Math.random()-.5)*0.01;
      m.vy += (dy/dist)*pullC - pullZ - 0.04*m.energy + (Math.random()-.5)*0.01;
      const sp = Math.hypot(m.vx,m.vy), maxS = 1.55*m.energy; if(sp>maxS){ m.vx=m.vx/sp*maxS; m.vy=m.vy/sp*maxS; }
      m.vx *= 0.992; m.vy *= 0.992; m.x += m.vx * (dt*0.06+0.2); m.y += m.vy * (dt*0.06+0.2);

      // mark when touching candle, but not if already inside a bocal
      if (isInside && !insideAnyBocal(m.x, m.y)) { if(m.markedUntil <= state.t){ SFX.mark(); } m.markedUntil = state.t + state.markDurationMs; }

      // bank only if marked AND candle near bocal AND within radius
      if (m.markedUntil > state.t) {
        for(let i=0;i<state.bocals.length;i++){
          const b = state.bocals[i]; const r = state.bocalR * (0.9 + 0.1*b.charge);
          const active = Math.hypot(cx-b.x, cy-b.y) < r*state.bocalActiveRangeFactor; if(!active) continue;
          const d = Math.hypot(m.x-b.x, m.y-b.y); if(d < r){ m.x=-99999; bankMoth(i); break; }
        }
      }

      if (isInside && !m.inSafe) { m.inSafe = true; state.score += 5; state.saved += 1; }
      else if (!isInside && m.inSafe) { m.inSafe = false; }

      if (m.y < state.zapper.y + 3*devicePixelRatio) {
        state.lost++; state.score = Math.max(0, state.score - 20);
        state.candle.r = clamp(state.candle.r - state.lightLossOnDeath * maxR, minR, maxR);
        state.streak = 0; state.mult = 1.0; m.x = -99999; SFX.zap(); if (Math.random() < .35) toast('a tiny star went out');
      }
    }

    const cap = 0.10 * maxR; const recharge = Math.min(cap, insideCount * state.rechargePerSec * maxR) * dtSec; state.candle.r = clamp(state.candle.r + recharge, minR, maxR);
    state.moths = state.moths.filter(m => m.x>-9999 && m.x>-60 && m.x < W+60 && m.y>-60 && m.y<H+80);

    scoreEl.textContent = String(state.score); banksEl.textContent = String(state.banks); streakEl.textContent = 'x' + state.mult.toFixed(1); lostEl.textContent  = String(state.lost); jarsEl.textContent = String(state.bocals.length);
    const pct = Math.round( clamp((state.candle.r - minR)/(maxR - minR), 0, 1) * 100 ); lightPctEl.textContent = pct + '%';
    timeEl.textContent = fmtTime(state.playMs);

    if (state.candle.r <= minR) gameOver('candle burned out'); else if (state.bocals.length === 0) gameOver('all bocals went dark');
  }

  // ==== Draw ====
  function draw(){
    ctx.fillStyle = '#07090c'; ctx.fillRect(0,0,W,H);
    // Zapper visuals
    const zy=state.zapper.y, pulse=state.zapper.pulse = 0.5 + Math.sin(state.t*0.02 + Math.random()*0.5)*0.5;
    const zapGlow = ctx.createRadialGradient(W/2, zy, 5, W/2, zy, 200*devicePixelRatio); zapGlow.addColorStop(0, 'rgba(151,223,252,0.45)'); zapGlow.addColorStop(1, 'rgba(151,223,252,0)'); ctx.fillStyle = zapGlow; ctx.fillRect(0,0,W,zy+200*devicePixelRatio);
    const hz=6+Math.floor(pulse*6); for(let k=0;k<hz;k++){ const y=zy + k*3*devicePixelRatio; ctx.strokeStyle=`rgba(151,223,252,${0.5 - k*0.04})`; ctx.lineWidth=2.5*devicePixelRatio; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    const zgrad = ctx.createLinearGradient(0,0,0,zy+24*devicePixelRatio); zgrad.addColorStop(0,'rgba(151,223,252,0.35)'); zgrad.addColorStop(1,'rgba(151,223,252,0)'); ctx.fillStyle=zgrad; ctx.fillRect(0,0,W,zy+24*devicePixelRatio);

    // Bocals
    drawBocals();

    // Candle
    const cpos = candlePosAvoidingBocals(state.mouse.x, state.mouse.y); const cx=cpos.x, cy=cpos.y, cr=state.candle.r;// 2) In your draw() function, replace the existing moth loop with this:
for (const m of state.moths) {
  drawMoth(m);
}


    // Vignette
    const vg = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.2, W/2,H/2,Math.max(W,H)*0.7); vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.45)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
  }

  // ==== Loop / start ====
  let last=0; function loop(t){ if(!last) last=t; const dt=t-last; last=t; if(state.running){ step(dt); draw(); } else { draw(); const cpos=candlePosAvoidingBocals(state.mouse.x, state.mouse.y); state.mouse.x += (W*0.5 - cpos.x)*0.02; state.mouse.y += (H*0.6 - cpos.y)*0.02; } requestAnimationFrame(loop); }
  function start(){ titleEl.style.display='none'; closeBtn.style.display='none'; reloadBtn.style.display='none'; state.running=true; reset(); ensureAudio(); if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); } }

  addEventListener('resize', ()=>{ W=canvas.width=innerWidth*devicePixelRatio; H=canvas.height=innerHeight*devicePixelRatio; canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; state.zapper.y=28*devicePixelRatio; setupCandle(); });
  setInterval(()=>{ if(!state.running) return; if(Math.random()<.18) toast(whispers[(Math.random()*whispers.length)|0]); }, 4200);
  addEventListener('keydown', (e)=>{ if((e.code==='Enter') && !state.running) start(); });
  addEventListener('click', ()=>{ if(!state.running) start(); });

  // Self-test
  function runSelfTests(){ try { console.assert(typeof ctx.beginPath === 'function', 'ctx.beginPath exists'); console.log('%cSelf-tests passed','color:#9fe'); } catch(e) { console.warn('Self-tests failed', e); } }
  runSelfTests(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
